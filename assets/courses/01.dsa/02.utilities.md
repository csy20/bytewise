# Mathematical Algorithms for Competitive Programming

> ğŸ§  **Mental Model:** Think of these utilities as your **mathematical Swiss Army knife**. Just like you don't reinvent a knife each time you need to cut something, you don't re-derive GCD or modular inverse each time â€” you use these battle-tested tools!

---

## Table of Contents
1. GCD & LCM
2. Fast Power (Binary Exponentiation)
3. Modular Arithmetic
4. Factorials & Combinations
5. Prime Sieve
6. Prime Factorization
7. Prefix/Suffix Sums
8. Difference Arrays

---

## GCD & LCM

> ğŸ§  **Mental Model:** GCD is like finding the **largest common tile size** that perfectly fits two room dimensions. If rooms are 48m and 18m, the largest tile that fits both evenly is 6m!

### Greatest Common Divisor (GCD)

**What it is:** The largest number that divides both numbers without remainder.

**How it works:** Uses the Euclidean algorithm based on this fact:
- `gcd(a, b) = gcd(b, a % b)`
- When `b = 0`, the answer is `a`

**Why it works:** If `d` divides both `a` and `b`, then `d` also divides `a - k*b` for any integer `k`. The remainder `a % b` is just `a - k*b` where `k = a/b`.

```cpp
// Recursive GCD - Euclidean Algorithm
int gcd(int a, int b) {
    if (b == 0) return a;
    return gcd(b, a % b);
}

// Iterative version (preferred for performance)
int gcd_iter(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

// C++17 has built-in gcd
#include <numeric>
// std::gcd(a, b)
```

**Example trace:**
```
gcd(48, 18)
= gcd(18, 48 % 18)  // 48 % 18 = 12
= gcd(18, 12)
= gcd(12, 18 % 12)  // 18 % 12 = 6
= gcd(12, 6)
= gcd(6, 12 % 6)    // 12 % 6 = 0
= gcd(6, 0)
= 6
```

**Time Complexity:** O(log(min(a, b)))

### Least Common Multiple (LCM)

**What it is:** The smallest number that both numbers divide evenly.

**Formula:** `lcm(a, b) = (a * b) / gcd(a, b)`

**Why it works:** The product `a * b` contains all prime factors we need, but some are duplicated. Dividing by GCD removes the duplicates.

```cpp
long long lcm(long long a, long long b) {
    return (a / gcd(a, b)) * b;  // Divide first to avoid overflow!
}

// C++17 has built-in lcm
#include <numeric>
// std::lcm(a, b)
```

**âš ï¸ Overflow Warning:** Always divide first, then multiply!
```cpp
// BAD:  (a * b) / gcd(a, b)  // Can overflow!
// GOOD: (a / gcd(a, b)) * b  // Safe
```

---

## Fast Power (Binary Exponentiation)

> ğŸ§  **Mental Model:** Think of it like **folding a paper**. To get 2^10 layers, you don't stack 10 sheets â€” you fold once (2 layers), fold again (4 layers)... 10 folds = 1024 layers! Each fold doubles, so you only need logâ‚‚(n) folds.

### Basic Concept

**Goal:** Compute `a^n` efficiently.

**Naive approach:** Multiply `a` by itself `n` times â†’ O(n)

**Smart approach:** Use the binary representation of `n` â†’ O(log n)

**Key insight:**
```
a^n = (a^2)^(n/2)           if n is even
a^n = a * (a^2)^((n-1)/2)   if n is odd
```

**How it works:** 
- Example: `3^13 = 3^(1101 in binary) = 3^8 * 3^4 * 3^1`
- We only multiply powers of 2: `3^1, 3^2, 3^4, 3^8, ...`

```cpp
// Recursive version
long long fast_power(long long a, long long n) {
    if (n == 0) return 1;
    
    long long half = fast_power(a, n / 2);
    
    if (n % 2 == 0) {
        return half * half;
    } else {
        return half * half * a;
    }
}

// Iterative version (preferred)
long long fast_power_iter(long long a, long long n) {
    long long result = 1;
    
    while (n > 0) {
        if (n & 1) {          // If n is odd
            result *= a;
        }
        a *= a;               // Square the base
        n >>= 1;              // Divide n by 2
    }
    
    return result;
}
```

**Example trace:** Compute `3^13`
```
n = 13 (binary: 1101)
result = 1, a = 3

Step 1: n=13 (odd)  â†’ result = 1*3 = 3,     a = 3*3 = 9,    n = 6
Step 2: n=6  (even) â†’ result = 3,           a = 9*9 = 81,   n = 3
Step 3: n=3  (odd)  â†’ result = 3*81 = 243,  a = 81*81 = 6561, n = 1
Step 4: n=1  (odd)  â†’ result = 243*6561 = 1594323, n = 0

Answer: 1594323
```

**Time Complexity:** O(log n)

---

## Modular Arithmetic

> ğŸ§  **Mental Model:** Think of modular arithmetic like a **12-hour clock**. After 12, it wraps to 1. So 15 o'clock = 3 o'clock (mod 12). We use this to keep huge numbers manageable!

### Why We Need It

Large powers like `2^1000000` overflow. We use modulo to keep numbers manageable.

### Basic Properties

```
(a + b) % m = ((a % m) + (b % m)) % m
(a - b) % m = ((a % m) - (b % m) + m) % m  // +m handles negative
(a * b) % m = ((a % m) * (b % m)) % m
```

**âš ï¸ Division doesn't work this way!** `(a/b) % m â‰  ((a%m)/(b%m)) % m`

### Modular Exponentiation

```cpp
long long mod_power(long long a, long long n, long long mod) {
    long long result = 1;
    a %= mod;  // Handle case where a >= mod
    
    while (n > 0) {
        if (n & 1) {
            result = (result * a) % mod;
        }
        a = (a * a) % mod;
        n >>= 1;
    }
    
    return result;
}
```

### Modular Inverse

**Problem:** Compute `(a / b) % m`

**Solution:** Find `b^(-1)` such that `(b * b^(-1)) % m = 1`

**Method 1:** Fermat's Little Theorem (when `m` is prime)
- `a^(m-1) â‰¡ 1 (mod m)` for prime `m`
- So `a^(-1) â‰¡ a^(m-2) (mod m)`

```cpp
long long mod_inverse(long long a, long long mod) {
    // Only works when mod is prime!
    return mod_power(a, mod - 2, mod);
}

long long mod_divide(long long a, long long b, long long mod) {
    return (a * mod_inverse(b, mod)) % mod;
}
```

**Method 2:** Extended Euclidean Algorithm (works for any coprime numbers)

```cpp
// Returns {gcd, x, y} such that ax + by = gcd(a,b)
tuple<long long, long long, long long> extended_gcd(long long a, long long b) {
    if (b == 0) {
        return {a, 1, 0};
    }
    
    auto [g, x1, y1] = extended_gcd(b, a % b);
    long long x = y1;
    long long y = x1 - (a / b) * y1;
    
    return {g, x, y};
}

long long mod_inverse_general(long long a, long long mod) {
    auto [g, x, y] = extended_gcd(a, mod);
    if (g != 1) return -1;  // Inverse doesn't exist
    return (x % mod + mod) % mod;
}
```

---

## Factorials & Combinations

### Basic Factorial

```cpp
const int MAXN = 1e6;
long long fact[MAXN];

void precompute_factorial() {
    fact[0] = 1;
    for (int i = 1; i < MAXN; i++) {
        fact[i] = fact[i-1] * i;
    }
}

// nCr = n! / (r! * (n-r)!)
long long nCr(int n, int r) {
    if (r > n || r < 0) return 0;
    return fact[n] / (fact[r] * fact[n - r]);
}
```

**Problem:** Factorials overflow very quickly! `21! > 10^18`

### Factorial with Modulus

```cpp
const long long MOD = 1e9 + 7;
const int MAXN = 1e6;
long long fact[MAXN], inv_fact[MAXN];

void precompute_factorial_mod() {
    fact[0] = 1;
    for (int i = 1; i < MAXN; i++) {
        fact[i] = (fact[i-1] * i) % MOD;
    }
    
    // Precompute inverse factorials
    inv_fact[MAXN - 1] = mod_power(fact[MAXN - 1], MOD - 2, MOD);
    for (int i = MAXN - 2; i >= 0; i--) {
        inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD;
    }
}

long long nCr_mod(int n, int r) {
    if (r > n || r < 0) return 0;
    
    long long result = fact[n];
    result = (result * inv_fact[r]) % MOD;
    result = (result * inv_fact[n - r]) % MOD;
    
    return result;
}
```

**How precomputing inverse factorials works:**
```
inv_fact[n] = 1 / n!
inv_fact[n-1] = 1 / (n-1)! = (1/n!) * n = inv_fact[n] * n
```

### Pascal's Triangle (Small n, r)

**Recurrence:** `C(n, r) = C(n-1, r-1) + C(n-1, r)`

```cpp
const int MAXN = 1001;
long long C[MAXN][MAXN];

void precompute_pascals_triangle() {
    for (int i = 0; i < MAXN; i++) {
        C[i][0] = C[i][i] = 1;
        for (int j = 1; j < i; j++) {
            C[i][j] = C[i-1][j-1] + C[i-1][j];
            // With mod: C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD;
        }
    }
}
```

**Time:** O(nÂ²), **Space:** O(nÂ²)

---

## Prime Sieve

> ğŸ§  **Mental Model:** Imagine writing numbers 1-100 on a board. Start at 2, cross out all multiples of 2. Move to 3, cross out all multiples of 3. Skip 4 (already crossed). Move to 5... The unmarked numbers left are primes! Like a methodical elimination game.

### Sieve of Eratosthenes

**Goal:** Find all primes up to `n`.

**How it works:**
1. Assume all numbers are prime
2. Start from 2 (first prime)
3. Mark all multiples of 2 as composite
4. Move to next unmarked number (3), mark its multiples
5. Repeat until âˆšn

**Why âˆšn is enough:** If `n = a * b` and `a > âˆšn`, then `b < âˆšn`, so `b` would have already marked `n` as composite.

```cpp
const int MAXN = 1e7;
bool is_prime[MAXN];
vector<int> primes;

void sieve(int n) {
    fill(is_prime, is_prime + n + 1, true);
    is_prime[0] = is_prime[1] = false;
    
    for (int i = 2; i <= n; i++) {
        if (is_prime[i]) {
            primes.push_back(i);
            
            // Mark all multiples as composite
            for (long long j = (long long)i * i; j <= n; j += i) {
                is_prime[j] = false;
            }
        }
    }
}
```

**Optimization:** Start marking from `i*i` because smaller multiples were already marked by smaller primes.

**Time Complexity:** O(n log log n) â‰ˆ O(n)  
**Space Complexity:** O(n)

### Optimized Sieve (Linear Sieve)

**Goal:** Mark each composite exactly once.

```cpp
const int MAXN = 1e7;
int smallest_prime_factor[MAXN];
vector<int> primes;

void linear_sieve(int n) {
    for (int i = 2; i <= n; i++) {
        if (smallest_prime_factor[i] == 0) {
            smallest_prime_factor[i] = i;
            primes.push_back(i);
        }
        
        for (int p : primes) {
            if (p > smallest_prime_factor[i] || i * p > n) break;
            smallest_prime_factor[i * p] = p;
        }
    }
}
```

**Time Complexity:** O(n) - truly linear!

---

## Prime Factorization

### Method 1: Trial Division

**How it works:** Divide by all primes up to âˆšn.

```cpp
vector<pair<int, int>> prime_factorize(int n) {
    vector<pair<int, int>> factors;  // {prime, count}
    
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            int count = 0;
            while (n % i == 0) {
                n /= i;
                count++;
            }
            factors.push_back({i, count});
        }
    }
    
    if (n > 1) {
        factors.push_back({n, 1});  // Remaining prime
    }
    
    return factors;
}
```

**Time Complexity:** O(âˆšn)

### Method 2: Using Precomputed SPF

**How it works:** Use smallest prime factor from sieve.

```cpp
vector<pair<int, int>> prime_factorize_spf(int n) {
    vector<pair<int, int>> factors;
    
    while (n > 1) {
        int p = smallest_prime_factor[n];
        int count = 0;
        
        while (n % p == 0) {
            n /= p;
            count++;
        }
        
        factors.push_back({p, count});
    }
    
    return factors;
}
```

**Time Complexity:** O(log n) after O(n) preprocessing

### Applications

```cpp
// Count number of divisors
int count_divisors(int n) {
    auto factors = prime_factorize(n);
    int count = 1;
    
    for (auto [p, exp] : factors) {
        count *= (exp + 1);  // (e+1) choices: p^0, p^1, ..., p^e
    }
    
    return count;
}

// Sum of divisors
int sum_divisors(int n) {
    auto factors = prime_factorize(n);
    int sum = 1;
    
    for (auto [p, exp] : factors) {
        // Sum of geometric series: (p^(e+1) - 1) / (p - 1)
        int term_sum = (pow(p, exp + 1) - 1) / (p - 1);
        sum *= term_sum;
    }
    
    return sum;
}
```

---

## Prefix/Suffix Sums

> ğŸ§  **Mental Model:** Think of prefix sums as a **running total on a receipt**. Instead of adding items each time someone asks "what's the subtotal up to item 5?", you pre-compute all running totals. Any range sum becomes just one subtraction!

### Prefix Sum

**Goal:** Answer "sum of elements from index `l` to `r`" in O(1).

**How it works:**
- Precompute: `prefix[i] = sum of arr[0...i-1]`
- Query: `sum(l, r) = prefix[r+1] - prefix[l]`

```cpp
vector<int> arr = {3, 1, 4, 1, 5, 9, 2, 6};
vector<long long> prefix(arr.size() + 1, 0);

// Build prefix sum
for (int i = 0; i < arr.size(); i++) {
    prefix[i + 1] = prefix[i] + arr[i];
}

// Query: sum from index l to r (inclusive)
long long range_sum(int l, int r) {
    return prefix[r + 1] - prefix[l];
}
```

**Example:**
```
arr    = [3, 1, 4, 1, 5, 9, 2, 6]
prefix = [0, 3, 4, 8, 9, 14, 23, 25, 31]

sum(2, 5) = prefix[6] - prefix[2] = 23 - 4 = 19
           = arr[2] + arr[3] + arr[4] + arr[5]
           = 4 + 1 + 5 + 9 = 19 âœ“
```

**Time Complexity:**
- Build: O(n)
- Query: O(1)

### 2D Prefix Sum

**Goal:** Sum of submatrix in O(1).

```cpp
vector<vector<int>> matrix(n, vector<int>(m));
vector<vector<long long>> prefix(n + 1, vector<long long>(m + 1, 0));

// Build 2D prefix sum
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        prefix[i][j] = matrix[i-1][j-1] 
                     + prefix[i-1][j] 
                     + prefix[i][j-1] 
                     - prefix[i-1][j-1];
    }
}

// Query: sum of submatrix from (r1,c1) to (r2,c2)
long long submatrix_sum(int r1, int c1, int r2, int c2) {
    r1++; c1++; r2++; c2++;  // Convert to 1-indexed
    return prefix[r2][c2] 
         - prefix[r1-1][c2] 
         - prefix[r2][c1-1] 
         + prefix[r1-1][c1-1];
}
```

**Why the formula works:**
- We want the green area
- Add full rectangle to (r2, c2)
- Subtract the left rectangle
- Subtract the top rectangle
- But we subtracted the corner twice, so add it back

### Suffix Sum

```cpp
vector<long long> suffix(arr.size() + 1, 0);

// Build suffix sum (from right to left)
for (int i = arr.size() - 1; i >= 0; i--) {
    suffix[i] = suffix[i + 1] + arr[i];
}

// sum from index l to end
long long suffix_sum(int l) {
    return suffix[l];
}
```

---

## Difference Arrays

> ğŸ§  **Mental Model:** Imagine you're adjusting temperature in a building. Instead of changing each room individually, you mark "+5Â° starts at room 3" and "-5Â° after room 7". Then one sweep applies all changes! Perfect for bulk range updates.

### 1D Difference Array

**Goal:** Apply range updates efficiently, then compute final array.

**Problem:** Add `x` to all elements from index `l` to `r`. Do this for `q` queries.

**Naive:** O(n) per query â†’ O(nq) total

**Smart:** Use difference array â†’ O(1) per query + O(n) final computation

**How it works:**
- `diff[i] = arr[i] - arr[i-1]`
- To add `x` to range `[l, r]`: 
  - `diff[l] += x`
  - `diff[r+1] -= x`
- Reconstruct: `arr[i] = arr[i-1] + diff[i]`

```cpp
vector<int> arr(n, 0);
vector<int> diff(n + 1, 0);

// Apply range update: add val to [l, r]
void range_add(int l, int r, int val) {
    diff[l] += val;
    diff[r + 1] -= val;
}

// After all updates, build final array
void build_array() {
    arr[0] = diff[0];
    for (int i = 1; i < n; i++) {
        arr[i] = arr[i-1] + diff[i];
    }
}
```

**Example:**
```
Initial: arr = [0, 0, 0, 0, 0, 0]
         diff = [0, 0, 0, 0, 0, 0, 0]

Query 1: Add 5 to [1, 3]
diff[1] += 5  â†’ diff = [0, 5, 0, 0, -5, 0, 0]

Query 2: Add 3 to [2, 5]
diff[2] += 3  â†’ diff = [0, 5, 3, 0, -5, 0, -3]
diff[6] -= 3

Build array:
arr[0] = 0
arr[1] = 0 + 5 = 5
arr[2] = 5 + 3 = 8
arr[3] = 8 + 0 = 8
arr[4] = 8 + (-5) = 3
arr[5] = 3 + 0 = 3
arr[6] = 3 + (-3) = 0

Final: arr = [0, 5, 8, 8, 3, 3]
```

### 2D Difference Array

**Goal:** Add value to a submatrix efficiently.

```cpp
vector<vector<int>> diff(n + 2, vector<int>(m + 2, 0));

// Add val to submatrix from (r1,c1) to (r2,c2)
void range_add_2d(int r1, int c1, int r2, int c2, int val) {
    diff[r1][c1] += val;
    diff[r1][c2 + 1] -= val;
    diff[r2 + 1][c1] -= val;
    diff[r2 + 1][c2 + 1] += val;
}

// Build final 2D array
void build_2d_array(vector<vector<int>>& arr) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (i > 0) diff[i][j] += diff[i-1][j];
            if (j > 0) diff[i][j] += diff[i][j-1];
            if (i > 0 && j > 0) diff[i][j] -= diff[i-1][j-1];
            arr[i][j] = diff[i][j];
        }
    }
}
```

**Time Complexity:**
- Each update: O(1)
- Build final array: O(nm)

---

## ğŸš¦ Algorithm Selection Decision Tree

```
What mathematical operation do I need?
â”‚
â”œâ”€ Need greatest common divisor?
â”‚   â””â”€ Use std::__gcd() or std::gcd() (C++17) â”€â”€â–º O(log min(a,b))
â”‚
â”œâ”€ Need large exponent (a^n)?
â”‚   â”œâ”€ Without modulo? â”€â”€â”€â”€â”€â”€â”€â”€â–º Fast Power (careful: overflow!)
â”‚   â””â”€ With modulo? â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º Modular Exponentiation â”€â”€â–º O(log n)
â”‚
â”œâ”€ Need (a / b) % MOD?
â”‚   â”œâ”€ MOD is prime? â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º Fermat: b^(MOD-2) % MOD
â”‚   â””â”€ MOD not prime? â”€â”€â”€â”€â”€â”€â”€â”€â–º Extended GCD
â”‚
â”œâ”€ Need all primes up to N?
â”‚   â”œâ”€ N â‰¤ 10^7? â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º Sieve of Eratosthenes â”€â”€â–º O(n log log n)
â”‚   â””â”€ Need SPF too? â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º Linear Sieve â”€â”€â–º O(n)
â”‚
â”œâ”€ Need to factorize single number?
â”‚   â”œâ”€ One-time query? â”€â”€â”€â”€â”€â”€â”€â–º Trial Division â”€â”€â–º O(âˆšn)
â”‚   â””â”€ Many queries? â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º Precompute SPF + lookup â”€â”€â–º O(log n)
â”‚
â”œâ”€ Need range sum queries?
â”‚   â”œâ”€ Static array? â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º Prefix Sum â”€â”€â–º O(n) build, O(1) query
â”‚   â””â”€ With updates? â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º Fenwick/Segment Tree (see later)
â”‚
â””â”€ Need bulk range additions?
    â””â”€ Apply all first, query later? â–º Difference Array â”€â”€â–º O(1) update
```

---

## ğŸ Debug Corner: Mathematical Pitfalls

### Bug #1: LCM Overflow

**âŒ Buggy Implementation:**
```cpp
long long lcm(long long a, long long b) {
    return (a * b) / __gcd(a, b);  // BUG: a*b can overflow!
}
```

**ğŸ” The Bug:** Even with `long long`, multiplying two large numbers before dividing can overflow.

**âœ… Correct Implementation:**
```cpp
long long lcm(long long a, long long b) {
    return (a / __gcd(a, b)) * b;  // Divide FIRST, then multiply
}
```

---

### Bug #2: Modular Inverse Without Checking

**âŒ Buggy Implementation:**
```cpp
long long mod_inverse(long long a, long long mod) {
    return mod_power(a, mod - 2, mod);  // BUG: Only works if mod is prime!
}
```

**ğŸ” The Bug:** Fermat's Little Theorem only works when `mod` is prime. If `mod` is composite, you get wrong results.

**âœ… Correct Implementation:**
```cpp
// For prime mod (most common in CP)
long long mod_inverse_prime(long long a, long long mod) {
    // Only call this when you KNOW mod is prime
    return mod_power(a, mod - 2, mod);
}

// General case: Extended GCD (works for any coprime a, mod)
long long mod_inverse_general(long long a, long long mod) {
    auto [g, x, y] = extended_gcd(a, mod);
    if (g != 1) return -1;  // Inverse doesn't exist!
    return (x % mod + mod) % mod;
}
```

---

### Bug #3: Negative Modulo

**âŒ Buggy Implementation:**
```cpp
int result = (a - b) % MOD;  // BUG: Can be negative in C++!
```

**ğŸ” The Bug:** In C++, `(-5) % 3 = -2`, not `1`. The % operator preserves the sign of the dividend.

**âœ… Correct Implementation:**
```cpp
int result = ((a - b) % MOD + MOD) % MOD;  // Always positive
```

---

### Bug #4: Sieve Starting from i*i with int

**âŒ Buggy Implementation:**
```cpp
for (int i = 2; i <= n; i++) {
    if (is_prime[i]) {
        for (int j = i * i; j <= n; j += i) {  // BUG: i*i overflows!
            is_prime[j] = false;
        }
    }
}
```

**ğŸ” The Bug:** When `i = 50000`, `i * i = 2.5 billion` which overflows `int`!

**âœ… Correct Implementation:**
```cpp
for (int i = 2; i <= n; i++) {
    if (is_prime[i]) {
        for (long long j = (long long)i * i; j <= n; j += i) {
            is_prime[j] = false;
        }
    }
}
```

---

### Bug #5: Division in Modular Arithmetic

**âŒ Buggy Implementation:**
```cpp
long long ans = (a / b) % MOD;  // BUG: Division doesn't work with mod!
```

**ğŸ” The Bug:** `(a / b) % MOD â‰  ((a % MOD) / (b % MOD)) % MOD`. Division is NOT distributive over modulo.

**âœ… Correct Implementation:**
```cpp
long long ans = (a * mod_inverse(b, MOD)) % MOD;  // Multiply by inverse

### Sieve Memory

```cpp
// For n = 1e8, bool array = 100 MB
// Use bitset for larger n
bitset<100000001> is_prime;
```

---

## Complete Example Program

```cpp
#include <bits/stdc++.h>
using namespace std;

const long long MOD = 1e9 + 7;
const int MAXN = 1e6 + 5;

// Precomputed arrays
bool is_prime[MAXN];
int spf[MAXN];
vector<int> primes;
long long fact[MAXN], inv_fact[MAXN];

long long mod_power(long long a, long long n, long long mod) {
    long long res = 1;
    a %= mod;
    while (n > 0) {
        if (n & 1) res = (res * a) % mod;
        a = (a * a) % mod;
        n >>= 1;
    }
    return res;
}

void sieve(int n) {
    fill(is_prime, is_prime + n + 1, true);
    is_prime[0] = is_prime[1] = false;
    
    for (int i = 2; i <= n; i++) {
        if (is_prime[i]) {
            primes.push_back(i);
            spf[i] = i;
            for (long long j = (long long)i * i; j <= n; j += i) {
                is_prime[j] = false;
                if (spf[j] == 0) spf[j] = i;
            }
        }
    }
}

void precompute_factorials(int n) {
    fact[0] = 1;
    for (int i = 1; i <= n; i++) {
        fact[i] = (fact[i-1] * i) % MOD;
    }
    
    inv_fact[n] = mod_power(fact[n], MOD - 2, MOD);
    for (int i = n - 1; i >= 0; i--) {
        inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD;
    }
}

long long nCr(int n, int r) {
    if (r > n || r < 0) return 0;
    long long res = fact[n];
    res = (res * inv_fact[r]) % MOD;
    res = (res * inv_fact[n - r]) % MOD;
    return res;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    sieve(MAXN - 1);
    precompute_factorials(MAXN - 1);
    
    // Example usage
    cout << "GCD(48, 18) = " << __gcd(48, 18) << "\n";
    cout << "2^10 = " << mod_power(2, 10, MOD) << "\n";
    cout << "10C3 = " << nCr(10, 3) << "\n";
    cout << "Is 97 prime? " << (is_prime[97] ? "Yes" : "No") << "\n";
    
    return 0;
}
```

---

## Summary Table

| Algorithm | Time | Space | Use Case |
|-----------|------|-------|----------|
| GCD (Euclidean) | O(log min(a,b)) | O(1) | Finding GCD/LCM |
| Fast Power | O(log n) | O(1) | Large exponents |
| Mod Power | O(log n) | O(1) | Exponents with mod |
| Factorial Precompute | O(n) | O(n) | Multiple nCr queries |
| Sieve of Eratosthenes | O(n log log n) | O(n) | All primes â‰¤ n |
| Linear Sieve | O(n) | O(n) | All primes + SPF |
| Prime Factorization | O(âˆšn) | O(log n) | Factor single number |
| Prefix Sum (1D) | O(n) build, O(1) query | O(n) | Range sum queries |
| Prefix Sum (2D) | O(nm) build, O(1) query | O(nm) | Submatrix sum |
| Difference Array | O(1) update, O(n) build | O(n) | Range updates |

